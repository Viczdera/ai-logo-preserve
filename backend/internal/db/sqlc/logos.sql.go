// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: logos.sql

package db

import (
	"context"
)

const createLogo = `-- name: CreateLogo :one
INSERT INTO logos (
    job_id,
    bounding_box,
    confidence,
    logo_type,
    s3_key
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, job_id, bounding_box, confidence, logo_type, s3_key, created_at
`

type CreateLogoParams struct {
	JobID       int64  `json:"job_id"`
	BoundingBox string `json:"bounding_box"`
	Confidence  int64  `json:"confidence"`
	LogoType    string `json:"logo_type"`
	S3Key       int64  `json:"s3_key"`
}

func (q *Queries) CreateLogo(ctx context.Context, arg CreateLogoParams) (Logo, error) {
	row := q.queryRow(ctx, q.createLogoStmt, createLogo,
		arg.JobID,
		arg.BoundingBox,
		arg.Confidence,
		arg.LogoType,
		arg.S3Key,
	)
	var i Logo
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.BoundingBox,
		&i.Confidence,
		&i.LogoType,
		&i.S3Key,
		&i.CreatedAt,
	)
	return i, err
}

const getLogosByJobID = `-- name: GetLogosByJobID :many
SELECT id, job_id, bounding_box, confidence, logo_type, s3_key, created_at FROM logos WHERE job_id = $1 ORDER BY confidence DESC
`

func (q *Queries) GetLogosByJobID(ctx context.Context, jobID int64) ([]Logo, error) {
	rows, err := q.query(ctx, q.getLogosByJobIDStmt, getLogosByJobID, jobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Logo{}
	for rows.Next() {
		var i Logo
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.BoundingBox,
			&i.Confidence,
			&i.LogoType,
			&i.S3Key,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
